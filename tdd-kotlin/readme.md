# TDD

## Chap02 TDD 시작하기

### TDD 사이클

- Red: 실패하는 테스트를 작성한다.
- Green: 테스트를 통과하는 프로덕션 코드를 작성한다.
- Refactor: 테스트를 통과하면 프로덕션 코드를 리팩토링한다.

### 중복에 관하여

- 테스트 코드의 중복을 무조건적으로 제거하지 말자
- 테스트 코드의 중복 제거가 가독성을 떨어뜨린다면 중복을 허용하자

### 테스트 코드 작성 순서

2장에서 암호 강도 측정 기능을 TDD로 구현했다. 테스트 코드 작성 순서는 다음과 같았다.

1. 모든 규칙을 충족하는 암호 강도는 '강함'
2. 길이만 8글자 미만이고 나머지 규칙은 충족하는 암호 강도는 '보통'
3. 숫자를 포함하지 않고 나머지 규칙은 충족하는 암호의 강도는 '보통'
4. 값이 없는 암호의 강도는 유효하지 않음
5. 대문자를 포함하지 않고 나머지 규칙은 충족하는 경우
6. 길이가 8글자 이상인 규칙만 충족하는 경우
7. 숫자 포함 규칙만 충족하는 경우
8. 대문자 포함 규칙만 충족하는 경우
9. 아무 규칙도 충족하지 않는 경우

이 순서는 그냥 정해진 것이 아닌 쉬운 경우에서 여려운 경우로 진행되었다. 또한 예외적인 경우에서 정상인 경우로 진행되었다.

## Chap03 테스트 코드 작성 순서

### 초반에 복잡한 테스트부터 진행하지 마라

초반부터 복잡한 상황을 테스트로 추가하면 해당 테스트를 통과시키기 위해 한 번에 구현해야 할 코드가 많아진다.  
한 번에 구현해야 하는 시간이 짧아지면 짧아질수록 디버깅에 유리하다. 작성한 코드양이 많지 않은 상황에서 우리는 더 빠르게  
디버깅할 수 있는 상황속에서 코딩을 할 수 있다.

### 예외 상황을 먼저 테스트

다양한 예외 상황은 복잡한 `if-else`문을 만들게 된다. 예외 상황을 고려하지 않은 테스트 코드는 중간에 요구사항이나  
엣지 케이스를 고려하기 시작하면 많은 부분을 바꿔야하고, 중복되는 조건절이 계속해서 추가된다. 이는 코드를 복잡하게 만들고 버그 발생 가능성을 높인다.

### 테스트할 목록을 먼저 만들어라

우선 단순한 것부터 떠올려가며 테스트할 목록을 만들자. 그리고 그렇게 나열한 것들 중 가장 단순한 것에서 복잡한 것으로 진행하자.  
처음부터 너무 많은 사례를 다루려고 하지 않아도 좋다. 처음부터 모든 케이스를 다루려고 하면 시간이 오래걸린다. 개발을 진행하다보면 테스트 사례를 발견할 수 있다.
그리고 테스트 코드 작성이 힘들다면 Assertion을 먼저 만들자. 검증 코드를 먼저 만들다보면 구현할 내용도 떠오르게 된다.

## Chap04 TDD와 기능 명세, 그리고 설계

### 설계를 지원하는 TDD를 위한 조언

- 이름을 잘지어라. 타입의 이름, 메서드의 이름, 변수의 이름 등을 잘 짓는 것은 설계를 잘하는 것과 같다.
- 필요한만큼만 설계하자. 미리 앞서서 여러 기능을 만들려고 하지말자.

### Chap06 테스트 코드의 구성

### 기능에서의 상황

기능은 주어진 상황에 따라 다르게 동작한다. 파일에서 숫자를 일겅와 숫자의 합을 구하는 경우 다음과 같이 작성할 수 있다.

```java
File datafile = new File("data.txt");
long sum = MathUtils.sum(datafile);
```

하지만 이 코드는 파일이 존재하지 않는 경우 Exception이 발생한다. 이처럼 주어진 상황에 따라 기능의 실행 결과는 달라진다.  
뛰어난 개발자는 어떤 상황이 실행 결과에 영향을 줄 수 있는지 찾기 위해 노력한다. 결과에 영향을 줄 수 있는 상황을 찾아내는 것은 중요하다.  
이를 고려하지않고 작성된 코드는 버그를 포함할 가능성이 크기 때문이다.

### 외부 상태와 테스트의 어려움

상황과 결과에 영향을 주는 외부 요인은 파일, DBMS, 외부 서버 등 다양하다. 이들 외부 환경을 테스트에 맞게 구성하는 것은 항상 가능한 것은 아니다.  
외부 환경을 테스트에 맞게 구성하는 것은 어렵다. 이러한 경우에는 외부 환경을 대체할 수 있는 방법을 찾아야 한다. 그것이 바로 Mock이다.

---

## Chap07 대역

### 대역이 필요한 이유

테스트 대상에서 파일 시스템을 사용하거나 테스트 대상에서 DB로부터 데이터를 조회하거나 데이터를 추가하는 경우, 외부 HTTP 통신에서는 대역이 필요하다.  
테스트 대상이 외부 요인에 의존하면 테스트를 작성하고 실행하기 어려워진다. 외부 요인은 테스트 작성을 어렵게 만들 뿐만 아니라 테스트 결과도 예측할 수  
없게 만든다.

### 대역의 종류

- Stub: 구현을 단순한 것으로 대체한다. 테스트에 맞게 단순히 원하는 동작을 수행한다.
- Fake: 제품에는 적합하지 않지만, 실제 동작하는 구현을 제공한다. DB 대신에 메모리를 이용한 예시가 대표적이다.
- Spy: 호출된 내역을 기록한다. 기록한 내용은 테스트 결과를 검증할 때 사용한다.
- Mock: 기대한 대로 상호작용하는지 행위를 검증한다. 기대한 대로 동작하지 않으면 익셉션을 발생할 수 있다. Mock은 Stub이자 Spy이다.



--- 

## Chap08 테스트 가능한 설계

### 테스트가 어려운 코드

- 파일 경로를 하드 코딩한 경우

---

## Chap11 테스트를 위한 조언

많은 개발자는 일정 압박에 시달려 코드를 충분히 테스트하지 않고 다음 기능을 구현하게 만든다. 이는 버그 가능성을 높인다.  
TDD는 이를 줄여줄 수 있으며 개발자를 스트레스로부터 해방시킬 수 있는 도구다. 하지만 TDD를 전파하기전에 본인부터 충분히 TDD를 익히기 바란다.  
TDD를 전파할때는 페어 프로그래밍이 도움이 될 수 있다. 뿐만 아니라 TDD를 모든 팀에 전파하고 싶거든 동조자를 꼭 찾길 바란다.

레거시 코드처럼 TDD를 하기 힘든 코드는 테스트 코드라도 만들어보길 바란다. 레거시에 테스트 코드를 추가하면 코드를 이해하는데 도움이 된다.  
만약 레거시 코드가 너무 거대해서 테스트하기 힘들다면, 코드의 일부분을 별도의 클래스 메서드로 만든 다음 테스트 코드를 작성해보자.

TDD를 도입하려고 하면 "개발할 시간도 없는데 언제 테스트 코드를 작성하냐?"와 같은 공격을 받을 수 있다. 하지만 개발 과정에서는  
프로덕션 코드를 작성하는 시간보다는 테스트하고 디버깅하는 시간이 제일 많다. TDD는 기능을 구현하자마자 테스트를 진행한다. 그리고 바로 전에  
코드를 작성했기 때문에 테스트에 실패해도 원인을 빨리 찾을 수 있다. 즉 TDD는 디버깅 시간을 줄여준다.



